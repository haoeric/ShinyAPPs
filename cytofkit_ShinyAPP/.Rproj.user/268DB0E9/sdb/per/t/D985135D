{
    "collab_server" : "",
    "contents" : "\nlibrary(ggplot2)\nlibrary(gplots)\nlibrary(reshape2)\nlibrary(reshape)\nlibrary(plyr)\nlibrary(VGAM)\nlibrary(FlowSOM)\n\n## Van Gassen S, Callebaut B and Saeys Y (2014). FlowSOM: Using self-organizing maps for \n## visualization and interpretation of cytometry data. \n## http://www.r-project.org, http://dambi.ugent.be.\n\n#' @import FlowSOM\nFlowSOM_integrate2cytofkit <- function(xdata, k, ...){\n    map <- FlowSOM:::SOM(xdata, silent = TRUE, ...)\n    metaCluster <- suppressMessages(FlowSOM::metaClustering_consensus(map$codes, k = k))\n    cluster <- metaCluster[map$mapping[,1]]\n}\n\n\n# FlowSOM, DensityPlot, DotPlot, ColorBySample\nvisuaPlot <- function(obj, xlab, ylab, zlab, pointSize=1, \n                      addLabel=TRUE, labelSize=1, sampleLabel = TRUE,\n                      FlowSOM_k = 40, selectSamples, removeOutlier = TRUE){\n    \n    data <- cbind(obj$allExpressionData, do.call(cbind, obj$dimReducedRes))\n    data <- as.data.frame(data)\n    clusterMethods <- names(obj$clusterRes)\n    for(cname in clusterMethods){\n        data[[cname]] <- as.factor(obj$clusterRes[[cname]])\n    }\n    \n    ## run FlowSOM in shinyAPP\n    if(zlab == \"runFlowSOM\"){\n        FlowSOM_cluster <- FlowSOM_integrate2cytofkit(obj$expressionData, FlowSOM_k)\n        data[[\"FlowSOM\"]] <- as.factor(FlowSOM_cluster)\n        clusterMethods <- c(clusterMethods, \"FlowSOM\")\n        zlab <- \"FlowSOM\"\n    }\n    \n    row.names(data) <- row.names(obj$expressionData)\n    samples <- sub(\"_[0-9]*$\", \"\", row.names(obj$expressionData))\n    \n    data <- data[samples %in% selectSamples, ]\n    nsamples <- samples[samples %in% selectSamples]\n    data$sample <- nsamples\n    sample_num <- length(unique(nsamples))\n    \n    colPalette <- colorRampPalette(c(\"blue\", \"turquoise\", \"green\", \n                                     \"yellow\", \"orange\", \"red\"))\n\n    if(zlab == \"DensityPlot\"){\n        densCol <- densCols(data[, c(xlab, ylab)], colramp = colPalette)\n        data$densCol <- densCol\n        gp <- ggplot(data, aes_string(x=xlab, y=ylab)) + \n            geom_point(colour=densCol, size = pointSize) + ggtitle(\"Density Plot\") +\n            theme(legend.position = \"right\") + xlab(xlab) + ylab(ylab) + theme_bw() + \n            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n            theme(axis.text=element_text(size=14), axis.title=element_text(size=18,face=\"bold\"))\n    }else if(zlab == \"DotPlot\"){\n        gp <- ggplot(data, aes_string(x=xlab, y=ylab)) + \n            geom_point(size = pointSize) + ggtitle(\"Dot Plot\") +\n            xlab(xlab) + ylab(ylab) + theme_bw() + \n            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n            theme(axis.text=element_text(size=14), axis.title=element_text(size=18,face=\"bold\"))\n    }else if(zlab == \"ColorBySample\"){\n        size_legend_row <- ceiling(sample_num/4)\n        gp <- ggplot(data, aes_string(x=xlab, y=ylab)) + \n            geom_point(aes(colour = sample), size = pointSize) + ggtitle(\"Color By Sample\") +\n            xlab(xlab) + ylab(ylab) + theme_bw() + \n            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n            theme(legend.position = \"bottom\", axis.text=element_text(size=14), axis.title=element_text(size=18,face=\"bold\")) +\n            guides(colour = guide_legend(nrow = size_legend_row, override.aes = list(size = 4)))\n    }else if(zlab %in% clusterMethods){\n        cluster_num <- length(unique(data[[zlab]]))\n        col_legend_row <- ceiling(cluster_num/15)\n        size_legend_row <- ceiling(sample_num/4)\n        \n        if(sampleLabel){\n            if (sample_num >= 8) {\n                shape_value <- LETTERS[1:sample_num]\n            } else {\n                shape_value <- c(1:sample_num) + 15\n            }\n            shapeLab <- \"sample\"\n            gp <- ggplot(data, aes_string(x=xlab, y=ylab, colour = zlab, shape = shapeLab)) + \n                geom_point(size = pointSize) + scale_shape_manual(values = shape_value) +\n                scale_colour_manual(values = rainbow(cluster_num)) + \n                guides(colour = guide_legend(nrow = col_legend_row, override.aes = list(size = 4)), \n                       shape = guide_legend(nrow = size_legend_row, override.aes = list(size = 4)))\n        }else{\n            gp <- ggplot(data, aes_string(x=xlab, y=ylab, colour = zlab)) + \n                geom_point(size = pointSize) + scale_colour_manual(values = rainbow(cluster_num)) + \n                guides(colour = guide_legend(nrow = col_legend_row, override.aes = list(size = 4)))\n        }\n         \n        if(addLabel){\n            edata <- data[ ,c(xlab, ylab, zlab)]\n            colnames(edata) <- c('x', \"y\", \"z\")\n            center <- aggregate(cbind(x,y) ~ z, data = edata, median)\n            gp <- gp + annotate(\"text\", label = center[,1], x=center[,2], y = center[,3], \n                                size = labelSize, colour = \"black\")\n        }\n        \n        gp <- gp + xlab(xlab) + ylab(ylab) + \n            theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + \n            theme(legend.position = \"bottom\", axis.text=element_text(size=14),\n                         axis.title=element_text(size=18,face=\"bold\"))\n    \n    }else{\n        ## ggplot aes cannot recognize marker names with symbol <>\n        title <- zlab\n        data <- data[ ,c(xlab, ylab, zlab)]\n        if(removeOutlier)\n            data[,zlab] <- remove_outliers(data[,zlab])\n        zlab <- \"Expression\"\n        colnames(data) <- c(xlab, ylab, zlab)\n        gp <- ggplot(data, aes_string(x = xlab, y = ylab, colour = zlab)) + \n            geom_point(size = pointSize) + ggtitle(title) +\n            scale_colour_gradient2(low=\"blue\", mid=\"lightyellow\", high=\"red\", midpoint=median(data[[zlab]])) +\n            theme(legend.position = \"right\") + xlab(xlab) + ylab(ylab) + theme_bw() + \n            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n            theme(axis.text=element_text(size=14), axis.title=element_text(size=18,face=\"bold\"))\n    }\n    \n    return(gp)\n}\n\n\nheatMap <- function(data, clusterMethod = \"DensVM\", type = \"mean\", selectSamples,\n                    cex_row_label = 1, cex_col_label = 1, scaleMethod = \"none\") {\n    exprs <- data$expressionData\n    samples <- sub(\"_[0-9]*$\", \"\", row.names(exprs))\n    exprs <- exprs[samples %in% selectSamples, ]\n    ifMultiFCS <- length(selectSamples) > 1\n    dataj <- data$clusterRes[[clusterMethod]][samples %in% selectSamples]\n    exprs_cluster <- data.frame(exprs, cluster = dataj)\n    \n    if(type == \"mean\"){\n        cluster_stat <- aggregate(. ~ cluster, data = exprs_cluster, mean)\n        rownames(cluster_stat) <- paste(\"cluster_\", cluster_stat$cluster, sep = \"\")\n        cluster_stat <- cluster_stat[ ,-which(colnames(cluster_stat) == \"cluster\")]\n    }else if (type == \"median\"){\n        cluster_stat <- aggregate(. ~ cluster, data = exprs_cluster, median)\n        rownames(cluster_stat) <- paste(\"cluster_\", cluster_stat$cluster, sep = \"\")\n        cluster_stat <- cluster_stat[ ,-which(colnames(cluster_stat) == \"cluster\")]\n    }else if(type == \"percentage\" && ifMultiFCS){\n        sampleName <- sub(\"_[0-9]*$\", \"\", row.names(exprs))\n        clusterCounts <- as.data.frame(table(sampleName, dataj))\n        colnames(clusterCounts) <- c(\"sample\", \"cluster\", \"cellCount\")\n        sampleCellCount <- as.data.frame(table(sampleName))\n        colnames(sampleCellCount) <- c(\"sample\", \"totalCellCount\")\n        clust_cellCount <- merge(clusterCounts, sampleCellCount, by = \"sample\")\n        clust_cellCount$percentage <- round(clust_cellCount$cellCount/clust_cellCount$totalCellCount * 100, 2)\n        cluster_stat <- reshape::cast(clust_cellCount, sample ~ cluster, value = \"percentage\")\n        percColNames <- cluster_stat$sample\n        cluster_stat <- cluster_stat[, -which(colnames(cluster_stat) == \"sample\")]\n        percRowNames <- paste(\"cluster_\", colnames(cluster_stat), sep = \"\")\n        cluster_stat <- t(as.matrix(cluster_stat))\n        row.names(cluster_stat) <- percRowNames\n        colnames(cluster_stat) <- percColNames\n        \n    }else{\n        return(NULL)\n    }\n\n    cluster_stat <- as.matrix(cluster_stat)\n    heatmap.2(cluster_stat, col = bluered, trace = \"none\", \n              symbreaks = FALSE, scale = scaleMethod, \n              margins = c(8, 8),\n              cexRow = cex_row_label, \n              cexCol = cex_col_label, \n              srtCol = 30, symkey = FALSE, \n              keysize = 1, key.par=list(mgp=c(2, 1, 0),mar=c(4, 3, 4, 0)),\n              main = paste(clusterMethod, type, \"heatmap\", sep = \" \"))\n}\n\n\n\nprogressionPlot <- function(data, orderCol=\"isomap_1\", clusterCol = \"cluster\", \n                            trend_formula=\"expression ~ sm.ns(Pseudotime, df=3)\"){\n    \n    progressionData <- data$progressionRes\n    if(!is.null(progressionData)){\n        data <- do.call(cbind, progressionData) \n        markers <- colnames(progressionData[[1]]) \n        colnames(data) <- c(markers, \"cluster\", colnames(progressionData[[3]]))\n       \n        if(!is.data.frame(data)) data <- data.frame(data, check.names = FALSE)\n        if(!all(markers %in% colnames(data))) stop(\"Unmatching markers found!\")\n        if(!(length(orderCol)==1 && orderCol %in% colnames(data)))\n            stop(\"Can not find orderCol in data\")\n        if(!(length(clusterCol)==1 && clusterCol %in% colnames(data)))\n            stop(\"Can not find clusterCol in data\")\n        \n        orderValue <- data[[orderCol]]\n        data <- data[order(orderValue), c(markers, clusterCol)]\n        data$Pseudotime <- sort(orderValue)\n        \n        mdata <- melt(data, id.vars = c(\"Pseudotime\", clusterCol))\n                      # variable.name = \"markers\", variable.name= \"expression\")\n        colnames(mdata) <- c(\"Pseudotime\", clusterCol, \"markers\", \"expression\")\n        mdata$markers <- factor(mdata$markers)\n        mdata[[clusterCol]] <- factor(mdata[[clusterCol]])\n        min_expr <- min(mdata$expression)\n        \n        ## tobit regression\n        vgamPredict <- ddply(mdata, .(markers), function(x) { \n            fit_res <- tryCatch({\n                vg <- suppressWarnings(vgam(formula = as.formula(trend_formula), \n                                            family = VGAM::tobit(Lower = min_expr, lmu = \"identitylink\"), \n                                            data = x, maxit=30, checkwz=FALSE))\n                res <- VGAM::predict(vg, type=\"response\")\n                res[res < min_expr] <- min_expr\n                res\n            }\n            ,error = function(e) {\n                print(\"Error!\")\n                print(e)\n                res <- rep(NA, nrow(x))\n                res\n            }\n            )\n            expectation = fit_res\n            data.frame(Pseudotime=x$Pseudotime, expectation=expectation)\n        })\n        \n        color_by <- clusterCol\n        plot_cols <- round(sqrt(length(markers)))\n        cell_size <- 1\n        x_lab <- orderCol\n        y_lab <- \"Expression\"\n        legend_title <- clusterCol\n        \n        ## copied from monocle package\n        monocle_theme_opts <- function(){\n            theme(strip.background = element_rect(colour = 'white', fill = 'white')) +\n                theme(panel.border = element_blank(), axis.line = element_line()) +\n                theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +\n                theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + \n                theme(panel.background = element_rect(fill='white')) +\n                theme(legend.position = \"right\") +\n                theme(axis.title = element_text(size = 15)) }\n        \n        q <- ggplot(aes(Pseudotime, expression), data=mdata) \n        q <- q + geom_point(aes_string(color=color_by), size=I(cell_size))\n        q <- q + geom_line(aes(Pseudotime, expectation), data=vgamPredict)\n        q <- q + facet_wrap(~markers, ncol=plot_cols, scales=\"free_y\")\n        q <- q + ylab(y_lab) + xlab(x_lab) + theme_bw()\n        q <- q + guides(colour = guide_legend(title = legend_title, override.aes = list(size = cell_size*3)))\n        q <- q + monocle_theme_opts() \n        \n        return(q)\n    }else{\n        return(NULL)\n    }\n}\n\n\nremove_outliers <- function(x, na.rm = TRUE, ...) {\n    qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)\n    H <- 1.5 * IQR(x, na.rm = na.rm)\n    y <- x\n    y[x < (qnt[1] - H)] <- qnt[1] - H\n    y[x > (qnt[2] + H)] <- qnt[2] + H\n    y\n}\n",
    "created" : 1465273023519.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "602070446",
    "id" : "D985135D",
    "lastKnownWriteTime" : 1465274259,
    "last_content_update" : 1465274259433,
    "path" : "~/SVNproject/BioC_release/cytofkitShinyAPP/global.R",
    "project_path" : "global.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}