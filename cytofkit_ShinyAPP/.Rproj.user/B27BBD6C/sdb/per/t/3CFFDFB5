{
    "collab_server" : "",
    "contents" : "## loading pacakge\nrequire(cytofkit)\nrequire(ggplot2)\nrequire(reshape2)\nrequire(plyr)\nrequire(VGAM)\n\n\n## Main function for scatter plot\nscatterPlot <- function(obj, plotMethod, plotFunction, pointSize=1, \n                      addLabel=TRUE, labelSize=1, sampleLabel = TRUE,\n                      FlowSOM_k = 40, selectSamples, facetPlot = FALSE, \n                      colorPalette = \"bluered\", labelRepel = FALSE, removeOutlier = TRUE){\n    \n    data <- data.frame(obj$expressionData, \n                       obj$dimReducedRes[[plotMethod]], \n                       do.call(cbind, obj$clusterRes), check.names = FALSE)\n    xlab <- colnames(obj$dimReducedRes[[plotMethod]])[1]\n    ylab <- colnames(obj$dimReducedRes[[plotMethod]])[2]\n    row.names(data) <- row.names(obj$expressionData)\n    \n    clusterMethods <- names(obj$clusterRes)\n    samples <- sub(\"_[0-9]*$\", \"\", row.names(obj$expressionData))\n    data <- data[samples %in% selectSamples, ]\n    nsamples <- samples[samples %in% selectSamples]\n    data$sample <- nsamples\n    sample_num <- length(unique(nsamples))\n\n    if(plotFunction == \"DensityPlot\"){\n        colPalette <- colorRampPalette(c(\"blue\", \"turquoise\", \"green\", \n                                         \"yellow\", \"orange\", \"red\"))\n        densCol <- densCols(data[, c(xlab, ylab)], colramp = colPalette)\n        data$densCol <- densCol\n        gp <- ggplot(data, aes_string(x=xlab, y=ylab)) + \n            geom_point(colour=densCol, size = pointSize) + ggtitle(\"Density Plot\") +\n            theme(legend.position = \"right\") + xlab(xlab) + ylab(ylab) + theme_bw() + \n            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n            theme(axis.text=element_text(size=14), axis.title=element_text(size=18,face=\"bold\"))\n    }else if(plotFunction == \"DotPlot\"){\n        gp <- ggplot(data, aes_string(x=xlab, y=ylab)) + \n            geom_point(size = pointSize) + ggtitle(\"Dot Plot\") +\n            xlab(xlab) + ylab(ylab) + theme_bw() + \n            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n            theme(axis.text=element_text(size=14), axis.title=element_text(size=18,face=\"bold\"))\n    }else if(plotFunction == \"ColorBySample\"){\n        size_legend_row <- ceiling(sample_num/4)\n        sample <- \"sample\"\n        gp <- ggplot(data, aes_string(x=xlab, y=ylab, colour = sample)) +\n            geom_point(size = pointSize) + ggtitle(\"Color By Sample\") +\n            xlab(xlab) + ylab(ylab) + theme_bw() + theme(legend.position = \"bottom\") +\n            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n            theme(axis.text=element_text(size=14), axis.title=element_text(size=18,face=\"bold\")) +\n            guides(colour = guide_legend(nrow = size_legend_row, override.aes = list(size = 4)))\n    }else if(plotFunction == \"All Markers\"){\n        gp <- cytof_wrap_colorPlot(data = data, \n                              xlab = xlab, \n                              ylab = ylab, \n                              markers = colnames(obj$expressionData), \n                              colorPalette = colorPalette,\n                              pointSize = pointSize, \n                              removeOutlier = TRUE)\n        \n    }else if(plotFunction == \"All Markers(scaled)\"){\n        gp <- cytof_wrap_colorPlot(data = data, \n                                   xlab = xlab, \n                                   ylab = ylab, \n                                   markers = colnames(obj$expressionData), \n                                   scaleMarker = TRUE,\n                                   colorPalette = colorPalette,\n                                   pointSize = pointSize, \n                                   removeOutlier = TRUE)\n        \n    }else if(plotFunction %in% clusterMethods){\n        gp <- cytof_clusterPlot(data = data, \n                                xlab = xlab, \n                                ylab = ylab, \n                                cluster = plotFunction, \n                                sample = \"sample\",\n                                title = plotFunction, \n                                type = ifelse(facetPlot, 2, 1),\n                                point_size = pointSize, \n                                addLabel = addLabel, \n                                labelSize = labelSize, \n                                sampleLabel = sampleLabel,\n                                labelRepel = labelRepel,\n                                fixCoord = FALSE)\n    }else{\n        gp <- cytof_colorPlot(data = data, \n                              xlab = xlab, \n                              ylab = ylab, \n                              zlab = plotFunction, \n                              colorPalette = colorPalette,\n                              pointSize = pointSize, \n                              removeOutlier = TRUE)\n    }\n    \n    return(gp)\n}\n\n## Facet wrap plot of marker exporession\ncytof_wrap_colorPlot <- function(data, xlab, ylab, markers, scaleMarker = FALSE,\n                            colorPalette = c(\"bluered\", \"topo\", \"heat\", \"terrain\", \"cm\"), \n                            pointSize=1, \n                            removeOutlier = TRUE){\n    \n    remove_outliers <- function(x, na.rm = TRUE, ...) {\n        qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)\n        H <- 1.5 * IQR(x, na.rm = na.rm)\n        y <- x\n        y[x < (qnt[1] - H)] <- qnt[1] - H\n        y[x > (qnt[2] + H)] <- qnt[2] + H\n        y\n    }\n    \n    data <- as.data.frame(data)\n    title <- \"Marker Expression Level Plot\"\n    data <- data[,c(xlab, ylab, markers)]\n    \n    if(removeOutlier){\n        for(m in markers){\n            data[[m]] <- remove_outliers(data[ ,m])\n        }\n    }\n    \n    if(scaleMarker){\n        data[ ,markers] <- scale(data[ ,markers], center = TRUE, scale = TRUE)\n        ev <- \"ScaledExpression\"\n        data <- melt(data, id.vars = c(xlab, ylab), \n                     measure.vars = markers,\n                     variable.name = \"markers\", \n                     value.name = ev)\n    }else{\n        ev <- \"Expression\"\n        data <- melt(data, id.vars = c(xlab, ylab), \n                     measure.vars = markers,\n                     variable.name = \"markers\", \n                     value.name = ev)\n    }\n    \n\n    colorPalette <- match.arg(colorPalette)\n    switch(colorPalette,\n           bluered = {\n               myPalette <- colorRampPalette(c(\"blue\", \"white\", \"red\"))\n           },\n           topo = {\n               myPalette <- colorRampPalette(topo.colors(50))\n           },\n           heat = {\n               myPalette <- colorRampPalette(heat.colors(50))\n           },\n           terrain = {\n               myPalette <- colorRampPalette(terrain.colors(50))\n           },\n           cm = {\n               myPalette <- colorRampPalette(cm.colors(50))\n           }\n    )\n    zlength <- nrow(data)\n    grid_row_num <- round(sqrt(length(markers)))\n    gp <- ggplot(data, aes_string(x = xlab, y = ylab, colour = ev)) + \n        facet_wrap(~markers, nrow = grid_row_num, scales = \"fixed\") +\n        scale_colour_gradientn(name = ev, colours = myPalette(zlength)) +\n        geom_point(size = pointSize) + theme_bw() + coord_fixed() +\n        theme(legend.position = \"right\") + xlab(xlab) + ylab(ylab) + ggtitle(title) +\n        theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n        theme(axis.text=element_text(size=8), axis.title=element_text(size=12,face=\"bold\"))\n    \n    return(gp)\n}\n\n## Heat Map\nheatMap <- function(data, clusterMethod = \"DensVM\", type = \"mean\", selectSamples,\n                    cex_row_label = 1, cex_col_label = 1, scaleMethod = \"none\") {\n    exprs <- data$expressionData\n    samples <- sub(\"_[0-9]*$\", \"\", row.names(exprs))\n    mySamples <- samples %in% selectSamples\n    exprs <- exprs[mySamples, , drop = FALSE]\n    dataj <- data$clusterRes[[clusterMethod]][mySamples]\n    exprs_cluster <- data.frame(exprs, cluster = dataj, check.names = FALSE )\n    \n    cluster_stat <- cytof_clusterStat(data = exprs_cluster,\n                             cluster = \"cluster\", \n                             statMethod = type)\n    \n    cytof_heatmap(data = as.matrix(cluster_stat), \n                  baseName = paste(clusterMethod, type), \n                  scaleMethod = scaleMethod, \n                  cex_row_label = cex_row_label, \n                  cex_col_label = cex_col_label,\n                  margins = c(8, 8), \n                  keysize = 1, \n                  key.par=list(mgp=c(2, 1, 0), mar=c(4, 3, 4, 0))) \n}\n\n## density plot\n\n#' @param densData Data frame.\n#' @param stackRotation Rotation degree of density plot to the right side, range (0-90).\n#' @param stackSeperation Control factor for stack seperation interval, numeric value from 0-1, or auto.\n#'\n#' @importFrom plyr ldply\n#' @importFrom reshape2 melt\n#' @import ggplot2\nstackDenistyPlot <- function(data, densityCols, stackFactor,\n                             kernel = c(\"gaussian\", \"epanechnikov\", \"rectangular\",\n                                        \"triangular\", \"biweight\",\n                                        \"cosine\", \"optcosine\"),\n                             bw = \"nrd0\", adjust = 1,\n                             reomoveOutliers = FALSE, \n                             stackRotation = 0, \n                             stackSeperation = \"auto\",\n                             x_text_size = 2, \n                             strip_text_size = 7,\n                             legend_text_size = 0.5, \n                             legendRow = 1,\n                             legend_title = \"stackName\"){\n    \n    if(!is.numeric(stackRotation)){\n        stop(\"stackRotation must be a numeric number\")\n    }else if(stackRotation < 0 || stackRotation > 90){\n        stop(\"stackRotation must be a numeric number in range 0-90\")\n    }\n    \n    if(missing(densityCols)){\n        densityCols <- colnames(data)\n    }else if(any(!(densityCols %in% colnames(data)))){\n        stop(\"Unmatch densityCols found:\", paste(densityCols[!(densityCols %in% colnames(data))], collapse = \" \"))\n    }\n    \n    if(missing(stackFactor)){\n        warning(\"no stackFactor was provided!\")\n        stackFactor <- rep(\"stack\", length = nrow(data))\n    }else if(length(stackFactor) != nrow(data)){\n        stop(\"Length of stackFactor unequal row number of input data\")\n    }\n    kernel <- match.arg(kernel)\n    \n    stackCount <- length(unique(stackFactor))\n    densityCount <- length(densityCols)\n    \n    data <- data.frame(data[ ,densityCols, drop=FALSE], stackFactor = stackFactor, check.names = FALSE)\n    \n    densData <- .densityCal(data, kernel = kernel, bw = bw, adjust = adjust, reomoveOutliers = reomoveOutliers)\n    ## dataframe densData contains {stackName, x , y , densityName}\n    xStat <- aggregate(x ~ stackName + densityName, densData, max)\n    yStat <- aggregate(y ~ stackName + densityName, densData, max)\n    \n    if(stackSeperation == \"auto\"){\n        stackIntervals <- aggregate(y ~ densityName, yStat, function(x){0.8*median(x) * (1-(stackRotation/90)^0.2)^2})\n    }else if(stackSeperation < 0 || stackSeperation > 1){\n        stop(\"stackSeperation must be value in range 0-1\")\n    }else{\n        stackIntervals <- aggregate(y ~ densityName, yStat, function(x){median(x)*stackSeperation})\n    }\n    \n    stackShifts <- aggregate(x ~ densityName, xStat, function(x){max(x) * (stackRotation/90)})\n    \n    densData$stack_x <- densData$x + (as.numeric(densData$stackName)-1) * stackShifts$x[match(densData$densityName, stackShifts$densityName)]\n    densData$stack_y <- densData$y + (as.numeric(densData$stackName)-1) * stackIntervals$y[match(densData$densityName, stackIntervals$densityName)]\n    \n    ## segment lines, x tick, x label\n    alignSegments <- ldply(split(densData$x, densData$densityName),\n                           function(x){seq(min(x), max(x), length.out=5)},\n                           .id = \"densityName\")\n    alignSegments <- melt(alignSegments, id.vars=\"densityName\", variable.name=\"x_tick\", value.name = \"x\")\n    alignSegments$y <- min(densData$y)\n    alignSegments$xend <- alignSegments$x + (length(unique(densData$stackName))-1) * stackShifts$x[match(alignSegments$densityName, stackShifts$densityName)]\n    alignSegments$yend <- min(densData$y) + (length(unique(densData$stackName))-1) * stackIntervals$y[match(alignSegments$densityName, stackIntervals$densityName)]\n    \n    densityHeights <- aggregate(y ~ densityName, yStat, max)\n    alignSegments$tickXend <- alignSegments$x\n    alignSegments$tickYend <- alignSegments$y - densityHeights$y[match(alignSegments$densityName, densityHeights$densityName)] * 0.01\n    alignSegments$tickText <- format(alignSegments$x,scientific=TRUE, digits=3)\n    alignSegments$textY <- alignSegments$y - densityHeights$y[match(alignSegments$densityName, densityHeights$densityName)] * 0.03\n    \n    cat(\" Plotting ...\\n\")\n    stackDensityPlot_theme <- theme(legend.position = \"top\",\n                                    legend.title = element_text(size = rel(1)),\n                                    legend.text = element_text(size = rel(legend_text_size)),\n                                    strip.text = element_text(size=strip_text_size, lineheight=1, hjust = 0.5, vjust = 0.5),\n                                    axis.text.x = element_blank(),\n                                    axis.ticks.x = element_blank(),\n                                    axis.text.y = element_blank(),\n                                    axis.ticks.y = element_blank(),\n                                    panel.grid.major = element_blank(),\n                                    panel.grid.minor = element_blank(),\n                                    panel.border = element_blank(),\n                                    strip.background=element_rect(fill = \"grey90\", colour = NA))\n    \n    gp <- ggplot(densData, aes(x=stack_x, y=stack_y)) +\n        geom_segment(data = alignSegments,\n                     aes(x = x, y = y, xend = xend, yend = yend),\n                     color = \"grey80\", size=0.3) +\n        geom_segment(data = alignSegments,\n                     aes(x = x, y = y, xend = tickXend, yend = tickYend),\n                     color = \"grey20\", size=0.3) +\n        geom_text(data = alignSegments, aes(x = x, y = textY, label = tickText),\n                  hjust = 0.3, vjust = 1.1, size = x_text_size) +\n        geom_polygon(aes(fill=stackName, color=stackName), alpha = 0.15) +\n        facet_wrap(~densityName, scale = \"free\") +\n        xlab(\"\") + ylab(\"\") +\n        guides(col = guide_legend(title = legend_title, nrow = legendRow, byrow = TRUE),\n               fill = guide_legend(title = legend_title, nrow = legendRow, byrow = TRUE)) +\n        theme_bw() + stackDensityPlot_theme\n    \n    gp\n}\n\n\n#' Internal density calculation function serves for \\code{stackDenistyPlot}\n#'\n#' Output data frame with columns: stackName, x , y , densityName\n.densityCal <- function(data, kernel, bw, adjust, reomoveOutliers = FALSE){\n    cat(\"  Calculating Density for each stack column...\\n\")\n    print(table(data$stackFactor))\n    dataBystackFactor <- split(subset(data, select = -stackFactor), data$stackFactor)\n    densityWrap <- function(d, ...){\n        resOut <- NULL\n        for(i in colnames(d)){\n            x <- d[,i]\n            if(reomoveOutliers){\n                cat(\"  Remove outliers...\\n\")\n                x_IQR <- IQR(x)\n                x_lowLimit <- quantile(x, 0.25) - 1.5*x_IQR\n                x_highLimit <- quantile(x, 0.75) + 1.5*x_IQR\n                x <- x[x >= x_lowLimit && x <= x_highLimit]\n            }\n            dens <- density(x, ...)\n            densOut <- data.frame(x=dens$x, y=dens$y, densityName = i)\n            resOut <- rbind(resOut, densOut)\n        }\n        return(resOut)\n    }\n    \n    r <- ldply(dataBystackFactor, densityWrap,\n               kernel = kernel, bw = bw, adjust = adjust,\n               .progress = \"text\",\n               .id = \"stackName\")\n    return(r)\n}\n\n\n## Combined marker expression trend\ncytof_expressionTrends <- function(data, markers, clusters, \n                                  orderCol=\"isomap_1\", \n                                  clusterCol = \"cluster\", \n                                  reverseOrder = FALSE,\n                                  addClusterLabel = TRUE,\n                                  clusterLabelSize = 5,\n                                  segmentSize = 0.5,\n                                  min_expr = NULL, \n                                  trend_formula=\"expression ~ sm.ns(Pseudotime, df=3)\"){\n    \n    if(!is.data.frame(data)) data <- data.frame(data, check.names = FALSE)\n    if(!all(markers %in% colnames(data))) stop(\"Unmatching markers found!\")\n    if(!(length(orderCol)==1 && orderCol %in% colnames(data)))\n        stop(\"Can not find orderCol in data!\")\n    if(!(length(clusterCol)==1 && clusterCol %in% colnames(data)))\n        stop(\"Can not find clusterCol in data!\")\n    if(!missing(clusters)){\n        if(!all(clusters %in% data[[clusterCol]]))\n            stop(\"Wrong clusters selected!\")\n        data <- data[data[[clusterCol]] %in% clusters, , drop=FALSE]\n    }\n    \n    if(reverseOrder){\n        newOrderCol <- paste0(orderCol, \"(reverse)\")\n        data[[newOrderCol]] <- -data[[orderCol]]\n        orderCol <- newOrderCol\n    }\n    orderValue <- data[[orderCol]]\n    data <- data[order(orderValue), c(markers, clusterCol)]\n    data$Pseudotime <- sort(orderValue)\n    \n    mdata <- melt(data, id.vars = c(\"Pseudotime\", clusterCol), \n                  variable.name = \"markers\", value.name= \"expression\")\n    colnames(mdata) <- c(\"Pseudotime\", clusterCol, \"markers\", \"expression\")\n    mdata$markers <- factor(mdata$markers)\n    mdata[[clusterCol]] <- factor(mdata[[clusterCol]])\n    min_expr <- min(mdata$expression)\n    \n    ## tobit regression\n    vgamPredict <- ddply(mdata, .(markers), function(x) { \n        fit_res <- tryCatch({\n            vg <- suppressWarnings(vgam(formula = as.formula(trend_formula), \n                                        family = VGAM::tobit(Lower = min_expr, lmu = \"identitylink\"), \n                                        data = x, maxit=30, checkwz=FALSE))\n            res <- VGAM::predict(vg, type=\"response\")\n            res[res < min_expr] <- min_expr\n            res\n        }\n        ,error = function(e) {\n            print(\"Error!\")\n            print(e)\n            res <- rep(NA, nrow(x))\n            res\n        }\n        )\n        expectation = fit_res\n        data.frame(Pseudotime=x[[\"Pseudotime\"]], expectation=expectation)\n    })\n    \n    color_by <- clusterCol\n    plot_cols <- round(sqrt(length(markers)))\n    cell_size <- 1\n    x_lab <- orderCol\n    y_lab <- \"Expression\"\n    legend_title <- \"Cluster\"\n    \n    ## copied from monocle package\n    monocle_theme_opts <- function(){\n        theme(strip.background = element_rect(colour = 'white', fill = 'white')) +\n            #theme(panel.border = element_blank(), axis.line = element_line()) +\n            theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +\n            theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + \n            theme(panel.background = element_rect(fill='white')) +\n            theme(legend.position = \"right\") +\n            theme(axis.title = element_text(size = 15)) +\n            theme(axis.text=element_text(size=8), axis.title=element_text(size=12,face=\"bold\"))}\n    \n    q <- ggplot(data=vgamPredict, aes_string(x=\"Pseudotime\", y=\"expectation\", col=\"markers\")) + geom_line(size = 1.5)\n    q <- q + ylab(y_lab) + xlab(x_lab) + theme_bw()\n    q <- q + guides(colour = guide_legend(title = legend_title, override.aes = list(size = cell_size*3)))\n    q <- q + monocle_theme_opts() \n    \n    # if(addClusterLabel){\n    #     # edata <- data[ ,c(\"Pseudotime\", clusterCol)]\n    #     # colnames(edata) <- c('x', \"z\")\n    #     # center <- aggregate(x ~ z, data = edata, median)\n    #     # center$y <- -0.5 ## add to the botom\n    #     # q <- q + geom_text_repel(data=center, aes(x=x, y=y, label=z), parse=TRUE)\n    #     mdata$cluster <- mdata[[clusterCol]]\n    #     center <- aggregate(cbind(Pseudotime, expression) ~ cluster + markers, data = mdata, median)\n    #     q <- q + geom_text_repel(data=center, aes(x=Pseudotime, y=expression, label=cluster),\n    #                              size = clusterLabelSize, fontface = 'bold',\n    #                              box.padding = unit(0.5, 'lines'),\n    #                              point.padding = unit(1.6, 'lines'),\n    #                              segment.color = '#555555',\n    #                              segment.size = segmentSize,\n    #                              arrow = arrow(length = unit(0.02, 'npc')))\n    # }\n    \n    q\n}\n\n## function for opening the results directory\nopendir <- function(dir = getwd()){\n    if (.Platform['OS.type'] == \"windows\"){\n        shell.exec(dir)\n    } else {\n        system(paste(Sys.getenv(\"R_BROWSER\"), dir))\n    }\n}\n\n\n",
    "created" : 1468216200014.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1471162964",
    "id" : "3CFFDFB5",
    "lastKnownWriteTime" : 1474008991,
    "last_content_update" : 1474008991,
    "path" : "~/GitProject/ShinyAPPs/cytofkit_ShinyAPP/global.R",
    "project_path" : "global.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}