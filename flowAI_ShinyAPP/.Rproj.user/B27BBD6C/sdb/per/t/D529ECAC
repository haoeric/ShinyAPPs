{
    "collab_server" : "",
    "contents" : "# FlowQ test\nrequire(RColorBrewer)\nrequire(flowCore)\nrequire(reshape2)\nrequire(plyr)\nrequire(scales)\nrequire(ggplot2)\n\n# Guess which channel captures time in a exprs, flowFrame or flowset\nfindTimeChannel <- function(xx) {\n    time <- grep(\"^Time$\", colnames(xx), value = TRUE, ignore.case = TRUE)[1]\n    if (is.na(time)) {\n        if (is(xx, \"flowSet\") || is(xx, \"ncdfFlowList\"))\n            xx <- exprs(xx[[1]]) else if (is(xx, \"flowFrame\"))\n                xx <- exprs(xx)\n            cont <- apply(xx, 2, function(y) all(sign(diff(y)) >= 0))\n            time <- names(which(cont))\n    }\n    if (!length(time) || length(time) > 1)\n        time <- NULL\n    return(time)\n}\n\n# Check if the Fcs file is ordered according to time otherwise it order it.\nord_fcs_time <- function(x, timeCh= \"Time\"){\n    xord <- order(exprs(x)[, timeCh])\n\n    if( !identical(xord, 1:nrow(x)) ){\n        warning(paste0(\"Expression data in the file \", basename(keyword(x)$FILENAME),\n                       \" were not originally ordered by time.\"))\n        params <- parameters(x)\n        keyval <- keyword(x)\n        sub_exprs <- exprs(x)[xord, ]\n        newx <- flowFrame(exprs = sub_exprs, parameters = params,\n                          description = keyval)\n        return(newx)\n    }else{\n        return(x)\n    }\n}\n\n\nflow_rate_bin <- function(x, second_fraction = 0.1, timeCh = \"Time\", timestep = 0.1){\n\n    xx <- exprs(x)[, timeCh]\n    idx <- c(1:nrow(x))\n    lenx <- length(xx)                                                  # num of time ticks\n\n    endsec <- ceiling(timestep * max(xx))                 # total seconds of the experiment\n    tbins <- seq(0, endsec/timestep, by = second_fraction/timestep)             # time bins\n    secbin <- seq(0, endsec, by = second_fraction)               # bin expressed in seconds\n    minbin <- round(secbin/60, 3)                                # bin expressed in minutes\n    tbCounts <- c(0, hist(xx, tbins, plot = FALSE)$counts)  # number of events per time bin\n\n    nrBins <- length(tbins) - 1\n    expEv <- lenx/(nrBins)           # median(tbCounts) # expected number of events per bin\n    binID <- do.call(c, mapply(rep, x = 1:length(tbCounts), times = tbCounts,\n                               SIMPLIFY = FALSE))\n\n    if (length(idx) != length(binID))\n        stop(\"length of cell ID not equal length of bin ID\")\n\n    flowRateData <- list(frequencies = cbind(tbins, minbin, secbin, tbCounts),\n                         cellBinID = data.frame(cellID = idx, binID = binID),\n                         info = data.frame(second_fraction = second_fraction,\n                                           expFrequency = expEv, bins = nrBins))\n    return(flowRateData)\n}\n\n\nflow_rate_plot <- function(flowRateData, lowerRateThres, upperRateThres,\n                           lowerTimeCut, UpperTimeCut) {\n\n    frequencies <- as.data.frame(flowRateData$frequencies)\n    second_fraction <- flowRateData$info$second_fraction\n    short_period <- quantile(frequencies$secbin, seq(0,1, length.out = 4))\n    long_period <- quantile(frequencies$secbin, seq(0,1, length.out = 3*10 + 1))\n\n    ## flow rate graph(frg)\n    frg <- ggplot(frequencies, aes_string(x=\"secbin\", y=\"tbCounts\")) + geom_line(colour=\"red\") +\n        theme_bw() + theme(panel.grid.major = element_blank(),\n                           panel.grid.minor = element_blank(),\n                           text=element_text(size = 14))\n    frg <- frg + geom_vline(xintercept=short_period, color=\"gray60\") +\n        geom_vline(xintercept=long_period, linetype = 2, color=\"gray60\")\n\n    frg <- frg + geom_hline(yintercept=c(lowerRateThres, upperRateThres), color=\"blue\",\n                            linetype = \"longdash\", size = 1.2, show_guide = TRUE)\n    frg <- frg + geom_vline(xintercept=c(lowerTimeCut, UpperTimeCut), color=\"blue\",\n                            linetype = \"longdash\", size = 1.2, show_guide = TRUE)\n\n    frg <- frg + labs(x= \"Seconds\", y= paste0(\"Number of cells per 1/\", 1/second_fraction, \" second\"),\n                      title= \"Flow Rate Plot\")\n\n    return(frg)\n}\n\nflow_rate_check <- function(flowRateData, lowerRateThres, upperRateThres,\n                           lowerTimeCut, UpperTimeCut) {\n\n    frequencies <- as.data.frame(flowRateData$frequencies)\n    cellBinID <- flowRateData$cellBinID\n\n    goodcell_x <- which(frequencies$secbin < UpperTimeCut & frequencies$secbin > lowerTimeCut)\n    goodcell_y <- which(frequencies$tbCounts < upperRateThres & frequencies$tbCounts > lowerRateThres)\n\n    flowRateQC <- cellBinID$cellID[ cellBinID$binID %in% intersect(goodcell_x, goodcell_y) ]\n    cat(\"flow rate high Q events: \", length(flowRateQC), \"\\n\")\n    return(flowRateQC)\n}\n\n\n\nflow_signal_bin <- function(x, channels = NULL, binSize=500, timeCh=\"Time\", \n    timestep=0.1, TimeChCheck = NULL) {\n\n    if (is.null(channels) || missing(channels) || is.na(channels)) {\n        parms <- setdiff(colnames(x), timeCh)\n    } else {\n        if (!all(channels %in% colnames(x)))\n            stop(\"Invalid channel(s)\")\n        parms <- channels\n    }\n\n    if (missing(binSize) || is.null(binSize) || is.na(binSize))\n        binSize <- 500\n   \n    ### Retriving time and expression info\n    exp <- exprs(x)\n    if (!is.null(TimeChCheck)) {\n        timex <- seq(from = 0, length.out = nrow(x), by = 0.1)\n    }else{\n        timex <- exp[, timeCh]\n    }\n    yy <- exp[, parms]  # channels data\n    idx <- c(1:nrow(x))\n    seconds <- timex * timestep\n    lenSec <- length(seconds)  # num of time ticks\n    uniSeconds <- unique(seconds)  # num of unique time tick\n    nrBins <- floor(lenSec/binSize)  # num of bins\n\n    if (length(uniSeconds) < nrBins || lenSec < binSize)\n        stop(\"Improper bin size\")\n\n    cf <- c(rep(1:nrBins, each = binSize), rep(nrBins + 1, lenSec - nrBins * binSize))  # id bins\n    stopifnot(length(cf) == lenSec)\n    tmpx <- split(seconds, cf)\n    xx2 <- sapply(tmpx, mean)       # mean of each time bin  (x axis)\n    yy2 <- as.matrix(ddply(as.data.frame(yy), .(cf), colwise(median)))[, -1]\n\n    return(list(exprsBin = cbind(timeSec = xx2, yy2), cellBinID = data.frame(cellID = idx, binID = cf),\n                bins = length(unique(cf)), binSize = binSize))\n}\n\n\nflow_signal_plot <- function(flowSignalData, lowerBinThres, upperBinThres) {\n\n    exprsBin <- flowSignalData$exprsBin\n\n    binID <- 1:nrow(exprsBin)\n    teCh <- grep(\"Time|time|Event|event\", colnames(exprsBin), value = T)\n    parms <- setdiff(colnames(exprsBin), teCh)\n    dataORIG <- exprsBin[, parms]     # first channel is time\n    data <- as.data.frame(dataORIG)\n    data$binID <- binID\n\n    longdata <- melt(data, id.vars = \"binID\", variable.name = \"marker\", value.name = \"value\")\n    FS_graph <- ggplot(longdata, aes(x = binID, y = value, col = marker), environment = environment()) +\n        geom_line() + facet_grid(marker ~ ., scales = \"free\") +\n        labs(x = \"Bin ID\", y = \"Median Intensity value\") + theme_bw() +\n        theme(strip.text.y = element_text(angle = 0, hjust = 1), axis.text = element_text(size = 10),\n              axis.title = element_text(size = 15), legend.position = \"none\") +\n        scale_x_continuous(breaks= pretty_breaks(n = 10)) +\n        scale_y_continuous(breaks= pretty_breaks(n = 3)) +\n        geom_rect(aes(xmin = lowerBinThres, xmax = upperBinThres, ymin = -Inf, ymax = Inf), fill = \"orange\", linetype = 0, alpha = 0.005)\n\n    return(FS_graph)\n}\n\n\nflow_signal_check <- function(flowSignalData, lowerBinThres, upperBinThres) {\n\n    exprsBin <- flowSignalData$exprsBin\n    cellBinID <- flowSignalData$cellBinID\n\n    goodBins <- cellBinID$binID < upperBinThres & cellBinID$binID > lowerBinThres\n    FlowSignalQC <- cellBinID$cellID[goodBins]\n\n    cat(\"flow signal check: \", length(FlowSignalQC), \"\\n\")\n    return(FlowSignalQC)\n}\n\n\nflow_margin_check <- function(x,  margin_channels = NULL, side = \"both\") {\n\n    if (is.null(margin_channels)) {\n        teCh <- grep(\"Time|time|Event|event\", colnames(x), value = T)\n        parms <- setdiff(colnames(x), teCh)\n    } else {\n        if (!all(margin_channels %in% colnames(x)))\n            stop(\"Invalid channel(s)\")\n        parms <- margin_channels\n    }\n    scatter_parms <- grep(\"FSC|SSC\", parms, value = T)\n\n    xx <- c(1:nrow(x))\n    yy <- x@exprs[, parms]\n    range <- range(x)\n    lenx <- length(xx)\n\n    ## lower check\n    if (side == \"lower\" || side == \"both\") {\n\n        out_neg_range <- apply(yy, 2, function(x) {\n            neg <- which(x < 0)\n            # Zscores <- (0.6745*(x[neg] + median(x[neg])))/mad(x[neg]) ## it\n            # calculates the Zscore outneg <- neg[which(Zscores < -3.5)]\n            min_value <- (-3.5 * mad(x[neg]) + (0.6745 * median(x[neg])))/0.6745  # -3.5 is the default threshold\n            if (is.na(min_value)) {\n                min(x) - 1\n            } else {\n                min_value\n            }\n        })\n    }\n\n    # n. bad cells for each channel\n    if (side == \"lower\" || side == \"both\") {\n        neg_bad_len <- sapply(parms, function(x) length(xx[yy[, x] <= out_neg_range[x]]))\n    }\n    if (side == \"upper\" || side == \"both\") {\n        pos_bad_len <- sapply(parms, function(x) length(xx[yy[, x] >= range[2,\n                                                                            x]]))\n    }\n\n    # badcellIDs\n    if (side == \"lower\" || side == \"both\") {\n        lowID <- do.call(c, lapply(parms, function(ch) {\n            xx[yy[, ch] <= out_neg_range[ch]]\n        }))\n        if(length(scatter_parms) != 0){   ### check for values less than 0 in scatter parameters\n            minSc <- apply(yy[,scatter_parms], 1, function(x){\n                min(x)\n            })\n            low_scatter_ID <- which(minSc < 0)\n            lowID <- unique(c(lowID, low_scatter_ID))\n        }\n    }\n    if (side == \"upper\" || side == \"both\") {\n        upID <- do.call(c, lapply(parms, function(ch) {\n            xx[yy[, ch] >= range[2, ch]]\n        }))\n    }\n\n    if (side == \"lower\") {\n        summary_bad_cells <- data.frame(lower_range = c(neg_bad_len,\n                                                        total_SUM = length(lowID), total_UNIQUE = length(unique(lowID))))\n        bad_lowerIDs <- unique(lowID)\n        bad_upperIDs <- NULL\n        badCellIDs <- unique(lowID)\n    } else if (side == \"upper\") {\n        summary_bad_cells <- data.frame(upper_range = c(pos_bad_len,\n                                                        total_SUM = length(upID), total_UNIQUE = length(unique(upID))))\n        bad_lowerIDs <- NULL\n        bad_upperIDs <- unique(upID)\n        badCellIDs <- unique(upID)\n    } else {\n        summary_bad_cells <- data.frame(lower_range = c(neg_bad_len,\n                                                        total_SUM = length(lowID), total_UNIQUE = length(unique(lowID))),\n                                        upper_range = c(pos_bad_len,\n                                                        total_SUM = length(upID), total_UNIQUE = length(unique(upID))))\n        bad_lowerIDs <- unique(lowID)\n        bad_upperIDs <- unique(upID)\n        badCellIDs <- unique(c(lowID,upID))\n    }\n\n    goodCellIDs <- setdiff(xx, badCellIDs)\n\n    cat(\"margin check:\", length(goodCellIDs), \"\\n\")\n\n    return(list(goodCellIDs = goodCellIDs, bad_lowerIDs = bad_lowerIDs,\n                bad_upperIDs = bad_upperIDs, events = lenx))\n}\n\n\n###  graph showing where the anomalies mostly happened\nflow_margin_plot <- function(FlowMarginData, binSize = 500) {\n\n    tot_events <- FlowMarginData$events\n    bad_lowerIDs <- FlowMarginData$bad_lowerIDs\n    bad_upperIDs <- FlowMarginData$bad_upperIDs\n\n    if (missing(binSize) || is.null(binSize) || is.na(binSize))\n        binSize <- 500\n    nrBins <- floor(tot_events/binSize)\n\n    cf <- c(rep(1:nrBins, each = binSize), rep(nrBins + 1, tot_events - nrBins * binSize))\n    tmpx <- split(1:tot_events, cf)\n\n    if(length(bad_lowerIDs) != 0 && length(bad_upperIDs) != 0){\n        lowline <- sapply(tmpx, function(x){\n            length(which(bad_lowerIDs %in% x))\n        })\n        upline <- sapply(tmpx, function(x){\n            length(which(bad_upperIDs %in% x))\n        })\n        ymax <- max(lowline, upline)\n        plot(lowline, type =\"l\", col = \"blue\", bty =\"n\",\n            ylim = c(0, ymax), xlab = \"segment ID\",\n            ylab = \"Number of cells removed\" )\n        lines(upline, col = \"red\")\n        legend(\"top\", c(\"Negative Outliers\", \"Upper Margine Events\"), lty = 1,bty = \"n\", cex = 0.7,\n            col = c(\"blue\", \"red\"))\n    }else if( length(bad_lowerIDs) != 0 && length(bad_upperIDs) == 0){\n        lowline <- sapply(tmpx, function(x){\n            length(which(bad_lowerIDs %in% x))\n        })\n        plot(lowline, type =\"l\", col = \"blue\", bty =\"n\", xlab = \"segment ID\",\n            ylab = \"Number of cells removed\" )\n        legend(\"top\", c(\"Negative Outliers\"), lty = 1,bty = \"n\", cex = 0.7,\n            col = \"blue\")\n    }else if( length(bad_lowerIDs) == 0 && length(bad_upperIDs) != 0){\n        upline <- sapply(tmpx, function(x){\n            length(which(bad_upperIDs %in% x))\n        })\n        plot(upline, type =\"l\", col = \"red\", bty =\"n\", xlab = \"segment ID\",\n            ylab = \"Number of cells removed\" )\n        legend(\"top\", c(\"Upper Margine Events\"), lty = 1,bty = \"n\", cex = 0.7,\n            col = \"red\")\n    }\n}\n\n\n## create new flowFrame with the parameter indicating good and bad cells\naddQC <- function(QCvector, sub_exprs, params, keyval){\n    \n    rs <- attr(sub_exprs, \"ranges\")\n    rs <- c(rs, rs[1])\n    sub_exprs <- cbind(sub_exprs, QCvector)\n    attr(sub_exprs, \"ranges\") <- rs\n    NN <- as.numeric(keyval[\"$PAR\"]) + 1\n    names(dimnames(sub_exprs)[[2]]) <- sprintf(\"$P%sN\", 1:NN)\n    pnr <- paste0(\"$P\", NN, \"R\")\n    pnb <- paste0(\"$P\", NN, \"B\")\n    pne <- paste0(\"$P\", NN, \"E\")\n    pnn <- paste0(\"$P\", NN, \"N\")\n    pns <- paste0(\"$P\", NN, \"S\")\n    flowCorePnRmax <- paste0(\"flowCore_$P\", NN, \"Rmax\")\n    flowCorePnRmin <- paste0(\"flowCore_$P\", NN, \"Rmin\")\n    o <- params@data\n    o[length(o[,1]) + 1,] <- c(\"QC\", \"bad > 10,000\", as.numeric(keyval$`$P1R`), 0, 20000)\n    rownames(o)[length(o[,1])] <- paste(\"$P\", NN, sep = \"\")\n    \n    outFCS <- new(\"flowFrame\", exprs=sub_exprs, parameters=new(\"AnnotatedDataFrame\",o), description=keyval)\n    description(outFCS)[pnr] <- max(20000, description(outFCS)$`$P1R`)\n    description(outFCS)[pnb] <- description(outFCS)$`$P1B`\n    description(outFCS)[pne] <- \"0,0\"\n    description(outFCS)[pnn] <- \"QC\"\n    description(outFCS)[pns] <- \"bad > 10,000\"\n    description(outFCS)$`$PAR` <- NN\n    description(outFCS)[flowCorePnRmax] <- 20000\n    description(outFCS)[flowCorePnRmin] <- 0\n    outFCS\n}  \n\n",
    "created" : 1468980789765.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2400118378",
    "id" : "D529ECAC",
    "lastKnownWriteTime" : 1463703652,
    "last_content_update" : 1463703652,
    "path" : "~/GitProject/flowAIshinyAPP/global.R",
    "project_path" : "global.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}